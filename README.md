# API DEVELOPMENT WITH FASTAPI

## INSTALLATION
```bash
pip install fastapi[all]
```
With the all option, you will install even the optional dependancies that you may or may not need.

## Introduction
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}
```
__app__ is an instance of the class FastAPI. It is the main object of our application. It is the instance of the class that FastAPI() returns.

__async def root()__ this is normal python function, the async keyword is not mandatory and is used if you are going to make asynchronous calls inside the function, like querying a database or making an API call.

removing the async keyword will not affect the functionality of the function.

__@app.get("/")__ this is a decorator, it is used to add functionality to the function. In this case, it is used to add the path to the function. The path is the URL that will be used to access the function.

### starting the server
```bash
uvicorn main:app --reload
```
__--reload__ will only be needed on the development server.

__ORDER MATTERS__

When you run an endpoint, fastapi goes through all the function from top down and picks the first path that matches your request. If you have two paths that match then the server will pick the first one and run with it.

### TESTING
To test the application we will use postman. Postman is a tool that allows us to make API calls to our server.
We can also use the __/docs__ or __/redoc__ endpoint to test our application. This endpoint is automatically generated by fastapi and it allows us to test our application.

When the api development is complete, we can create a frontend application that will consume the API. A pyhon client of some sort, This application will make __requests__ to the server and the server will respond with the __response__.


## POST REQUESTS
With a post request, we can send data to the server.

```python
from fastapi.params import Body
@app.post("/createpost")
def create_post(payload: dict = Body(...)):
    print(payload)
    return {"message": "Post created"}

```
__Body__ is a class that is used to get the body of the request. It is provided by __fastapi.params__. It contains the data sent to the server. 
In our snippet above __Body(...)__ is used to tell fastapi that the body is required. If we don't want the body to be required, we can use __Body(None)__. This will tell fastapi that the body is optional.
__Body(...)__ takes the data that's is sent and converts it to a python dictionary and stores it in the variable __payload__. __dict__ in our context above is a type hint. It tells fastapi that the data sent to the server is a dictionary.

You can then retrieve the data stored in the payload and store it in the database.


## SCHEMA
We want to force the user at the frontend to enter data explicitly in a way we have defined. We can do this by creating a schema.

With fastApi we will use a tool called __pydantic__ to create a schema. But pydantic is not limited to fastapi, it can be used with other frameworks.


```python
from pydantic import BaseModel

class Post(BaseModel):
    title: str
    content: str

@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    return {"message": "Post created successfully"}
```
__BaseModel__ is a class that is provided by pydantic. It is used to create a schema.
__create_post(new_post: Post)__ the new_post variable is an instance of the class Post. It is the data that is sent to the server. The data is then validated against the schema. If the data is valid, it is stored in the database. If the data is invalid, an error is returned.

With the schema defined, if we send data that does not comply, validation happens authomatically and we will we receive an error message. It also tries to convert the data to the type we have defined. If it fails, an error is returned.

To access a single value of the body sent we can __new_post.title__ or __new_post.content__.

### OPTIONAL FIELDS
```python
from typing import Optional

class Post(BaseModel):
    title: str
    content: str
    published: bool = False
    rating: Optiona[int] = None
```

Here we have an optional field __published__. It is optional because it has a default value that is assigned to it it the user does not assign one by default. We could assign it a value of True/False if we wanted to. We could use that value in the database to determine if the post is published or not.

To have a completely optional field, we can use __Optional__ from __typing__.
__rating__ is fully optional and hwhen not provided, it will be assigned a value of None.

The pydantic object has a method__dict()__ which converts it to a python dictionary.

```python
@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    print(new_post.dict())
    return {"message": "Post created successfully"}
```

## CRUD OPERATIONS

### creating and retrieving
STORING IN MEMORY
```python
my_posts = []

# creating a single post to memory - the array above
@app.post("/posts")
def create_post(post: Post):
    post_dict = post.dict()
    post_dict["id"] = randint(0, 1000000)
    my_posts.append(post_dict)
    return {"data": post_dict}

"""
with the code above, the default status code on success is 200, if we want to change it, we can do so by adding the status_code parameter to the function. We will add a status code that rerpresents success in creating a resource. We will use 201.
"""
@app.post("/posts", status_code=status.HTTP_201_CREATED)

# getting a single post from memory- the list above
def get_post_from_database(id: int):
    for post in my_posts:
        if post["id"] == id:
            return post

# retrieving the latest post
# We are bringing this section above the retrieval with id because they may collide
@app.get("/posts/latest")
def get_latest_post():
    return {"data": my_posts[-1]}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        response.status_code = status.HTTP_404_NOT_FOUND
        return {"detail": f"Post with id {id} not found"}
    return {"data": post}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"data": post}
```

### DELETING
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    my_posts.remove(post) # you could use the pop method
    return {"data": "Post deleted"}
```

### UPDATING
For updating, two methods are provided, PUT AND PATCH.
__PUT__ is used to update the entire resource. Even when you are updating a single element, you have to send the entire resource.

__PATCH__ is used to update a single element of the resource. It is used when you don't want to send the entire resource.

```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post):
    current = get_post_from_database(id)

    if not current:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")
    post_dict = post.dict()
    post_dict["id"] = id
    my_posts[id] = post_dict
    return {"data": post_dict}
```