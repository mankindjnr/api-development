# API DEVELOPMENT WITH FASTAPI

## INSTALLATION
```bash
pip install fastapi[all]
```
With the all option, you will install even the optional dependancies that you may or may not need.

## Introduction
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}
```
__app__ is an instance of the class FastAPI. It is the main object of our application. It is the instance of the class that FastAPI() returns.

__async def root()__ this is normal python function, the async keyword is not mandatory and is used if you are going to make asynchronous calls inside the function, like querying a database or making an API call.

removing the async keyword will not affect the functionality of the function.

__@app.get("/")__ this is a decorator, it is used to add functionality to the function. In this case, it is used to add the path to the function. The path is the URL that will be used to access the function.

### starting the server
```bash
uvicorn main:app --reload
```
__--reload__ will only be needed on the development server.

__ORDER MATTERS__

When you run an endpoint, fastapi goes through all the function from top down and picks the first path that matches your request. If you have two paths that match then the server will pick the first one and run with it.

### TESTING
To test the application we will use postman. Postman is a tool that allows us to make API calls to our server.
We can also use the __/docs__ or __/redoc__ endpoint to test our application. This endpoint is automatically generated by fastapi and it allows us to test our application.

When the api development is complete, we can create a frontend application that will consume the API. A pyhon client of some sort, This application will make __requests__ to the server and the server will respond with the __response__.


## POST REQUESTS
With a post request, we can send data to the server.

```python
from fastapi.params import Body
@app.post("/createpost")
def create_post(payload: dict = Body(...)):
    print(payload)
    return {"message": "Post created"}

```
__Body__ is a class that is used to get the body of the request. It is provided by __fastapi.params__. It contains the data sent to the server. 
In our snippet above __Body(...)__ is used to tell fastapi that the body is required. If we don't want the body to be required, we can use __Body(None)__. This will tell fastapi that the body is optional.
__Body(...)__ takes the data that's is sent and converts it to a python dictionary and stores it in the variable __payload__. __dict__ in our context above is a type hint. It tells fastapi that the data sent to the server is a dictionary.

You can then retrieve the data stored in the payload and store it in the database.


## SCHEMA
We want to force the user at the frontend to enter data explicitly in a way we have defined. We can do this by creating a schema.

With fastApi we will use a tool called __pydantic__ to create a schema. But pydantic is not limited to fastapi, it can be used with other frameworks.


```python
from pydantic import BaseModel

class Post(BaseModel):
    title: str
    content: str

@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    return {"message": "Post created successfully"}
```
__BaseModel__ is a class that is provided by pydantic. It is used to create a schema.
__create_post(new_post: Post)__ the new_post variable is an instance of the class Post. It is the data that is sent to the server. The data is then validated against the schema. If the data is valid, it is stored in the database. If the data is invalid, an error is returned.

With the schema defined, if we send data that does not comply, validation happens authomatically and we will we receive an error message. It also tries to convert the data to the type we have defined. If it fails, an error is returned.

To access a single value of the body sent we can __new_post.title__ or __new_post.content__.

### OPTIONAL FIELDS
```python
from typing import Optional

class Post(BaseModel):
    title: str
    content: str
    published: bool = False
    rating: Optiona[int] = None
```

Here we have an optional field __published__. It is optional because it has a default value that is assigned to it it the user does not assign one by default. We could assign it a value of True/False if we wanted to. We could use that value in the database to determine if the post is published or not.

To have a completely optional field, we can use __Optional__ from __typing__.
__rating__ is fully optional and hwhen not provided, it will be assigned a value of None.

The pydantic object has a method__dict()__ which converts it to a python dictionary.

```python
@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    print(new_post.dict())
    return {"message": "Post created successfully"}
```

## CRUD OPERATIONS

### creating and retrieving
STORING IN MEMORY
```python
my_posts = []

# creating a single post to memory - the array above
@app.post("/posts")
def create_post(post: Post):
    post_dict = post.dict()
    post_dict["id"] = randint(0, 1000000)
    my_posts.append(post_dict)
    return {"data": post_dict}

"""
with the code above, the default status code on success is 200, if we want to change it, we can do so by adding the status_code parameter to the function. We will add a status code that rerpresents success in creating a resource. We will use 201.
"""
@app.post("/posts", status_code=status.HTTP_201_CREATED)

# getting a single post from memory- the list above
def get_post_from_database(id: int):
    for post in my_posts:
        if post["id"] == id:
            return post

# retrieving the latest post
# We are bringing this section above the retrieval with id because they may collide
@app.get("/posts/latest")
def get_latest_post():
    return {"data": my_posts[-1]}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        response.status_code = status.HTTP_404_NOT_FOUND
        return {"detail": f"Post with id {id} not found"}
    return {"data": post}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"data": post}
```

### DELETING
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    my_posts.remove(post) # you could use the pop method
    return {"data": "Post deleted"}
```

### UPDATING
For updating, two methods are provided, PUT AND PATCH.
__PUT__ is used to update the entire resource. Even when you are updating a single element, you have to send the entire resource.

__PATCH__ is used to update a single element of the resource. It is used when you don't want to send the entire resource.

```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post):
    current = get_post_from_database(id)

    if not current:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")
    post_dict = post.dict()
    post_dict["id"] = id
    my_posts[id] = post_dict
    return {"data": post_dict}
```

## STRUCTURE
we currently have our working files in the base directory. We will create a folder called __app__ and move all our files there. We will also create a file called **__init__.py** in the base directory. This file will that folder to a python package.

Now with this new structure, to run our application using uvicorn, the command will change to:
```bash
uvicorn app.main:app --reload
```
__app__ is the name of the folder, __main__ is the name of the file and __app__ is the name of the instance of the class FastAPI.

***
***
# DATABASE
We don't interact with the database directly, instead we use a database management system. It sits in the middle between our application and the database. It is responsible for managing the database. It is also responsible for translating the data from the database to the application and vice versa.

We are going to use postgres as our database
### POSTGRES
Each instance of postgres can be carved into multiple separate databases. They can be operated separately.
install postgres and the pgAdmin to have a graphical user interface to manage the database.

in postgres when you insert items and want them to be returned back to you, you use the __returning__ keyword.
This will be useful when buidling our API since we want to send back the data that was inserted into the database.
```sql
INSERT INTO products (name, price, inventory) VALUES ('drves', 44, 1523) returning *;
```

while deleting items and want to see teh item you are deleting as it gets deleted, you could use the __return__ keyword.
```sql
DELETE FROM products where id = 11 RETURNING *;
```
***
***
### accessing the postgres db from our python file
```python
while True:
    try:
        conn = psycopg2.connect(host='localhost', database='fastapi', user='postgres', password='', cursor_factory=RealDictCursor)
        cursor = conn.cursor()
        print("DATABSE CONN IS A SUCCESS")
        break
    except Exception as error:
        print("DATABSE CONN IS A FAILURE", error)
        time.sleep(2)
```

In the code above we use a while loop to keep trying to connect if the connection fails.

__cursor_factory=RealDictCursor__ is used to return the data as a dictionary. This will be useful when we are returning the data to the user.

***
***
### retrieving all data from the database
```python
@app.get("/posts")
def get_posts():
    cursor.execute("SELECT * FROM posts")
    my_posts = cursor.fetchall()
    return {"data": my_posts}
```

***
***
### retrieving a single item from the database
```python
@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    cursor.execute("SELECT * FROM posts WHERE id = %s", (id,))
    post = cursor.fetchone()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"data": post}
```

__(id,)__ is a tuple. It is used to pass the id to the query. It is used to prevent sql injection.
We can also try __str(id),__ but it is not recommended since it is prone to sql injection.

***
***
### inserting data into the database
```python
cursor.execute("INSERT INTO posts (title, content, published) VALUES (%s, %s, %s) RETURNING *", (post.title, post.content, post.published))

new_post = cursor.fetchone()
conn.commit()
return {"data": new_post}
```

This way of inserting sanitizes the input hence preventing sql injection.
__RETURNING *__ is used to return the data that was inserted into the database.
__new_post = cursor.fetchone()__ is used to get the data that was inserted into the database.
__conn.commit()__ is used to commit the changes to the database. it pushes the changes to the database.

***
***

### DELETING DATA FROM THE DATABASE
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    cursor.execute("DELETE FROM posts WHERE id = %s returning *", (id,))
    deleted_post = cursor.fetchone()
    conn.commit()

    if not deleted_post:
        raise HTTPException(status_code=404, detail="Post not found")

    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

***
***

### UPDATING DATA IN THE DATABASE
```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post):
    cursor.execute("UPDATE posts SET title = %s, content = %s, published = %s WHERE id = %s RETURNING *", (post.title, post.content, post.published, id))
    
    updated_post = cursor.fetchone()
    conn.commit()

    if not updated_post:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")

    return {"data": updated_post}
```

***
***
