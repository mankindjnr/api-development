# API DEVELOPMENT WITH FASTAPI

## INSTALLATION
```bash
pip install fastapi[all]
```
With the all option, you will install even the optional dependancies that you may or may not need.

## Introduction
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}
```
__app__ is an instance of the class FastAPI. It is the main object of our application. It is the instance of the class that FastAPI() returns.

__async def root()__ this is normal python function, the async keyword is not mandatory and is used if you are going to make asynchronous calls inside the function, like querying a database or making an API call.

removing the async keyword will not affect the functionality of the function.

__@app.get("/")__ this is a decorator, it is used to add functionality to the function. In this case, it is used to add the path to the function. The path is the URL that will be used to access the function.

### starting the server
```bash
uvicorn main:app --reload
```
__--reload__ will only be needed on the development server.

__ORDER MATTERS__

When you run an endpoint, fastapi goes through all the function from top down and picks the first path that matches your request. If you have two paths that match then the server will pick the first one and run with it.

### TESTING
To test the application we will use postman. Postman is a tool that allows us to make API calls to our server.
We can also use the __/docs__ or __/redoc__ endpoint to test our application. This endpoint is automatically generated by fastapi and it allows us to test our application.

When the api development is complete, we can create a frontend application that will consume the API. A pyhon client of some sort, This application will make __requests__ to the server and the server will respond with the __response__.


## POST REQUESTS
With a post request, we can send data to the server.

```python
from fastapi.params import Body
@app.post("/createpost")
def create_post(payload: dict = Body(...)):
    print(payload)
    return {"message": "Post created"}

```
__Body__ is a class that is used to get the body of the request. It is provided by __fastapi.params__. It contains the data sent to the server. 
In our snippet above __Body(...)__ is used to tell fastapi that the body is required. If we don't want the body to be required, we can use __Body(None)__. This will tell fastapi that the body is optional.
__Body(...)__ takes the data that's is sent and converts it to a python dictionary and stores it in the variable __payload__. __dict__ in our context above is a type hint. It tells fastapi that the data sent to the server is a dictionary.

You can then retrieve the data stored in the payload and store it in the database.


## SCHEMA
We want to force the user at the frontend to enter data explicitly in a way we have defined. We can do this by creating a schema.

With fastApi we will use a tool called __pydantic__ to create a schema. But pydantic is not limited to fastapi, it can be used with other frameworks.


```python
from pydantic import BaseModel

class Post(BaseModel):
    title: str
    content: str

@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    return {"message": "Post created successfully"}
```
__BaseModel__ is a class that is provided by pydantic. It is used to create a schema.
__create_post(new_post: Post)__ the new_post variable is an instance of the class Post. It is the data that is sent to the server. The data is then validated against the schema. If the data is valid, it is stored in the database. If the data is invalid, an error is returned.

With the schema defined, if we send data that does not comply, validation happens authomatically and we will we receive an error message. It also tries to convert the data to the type we have defined. If it fails, an error is returned.

To access a single value of the body sent we can __new_post.title__ or __new_post.content__.

### OPTIONAL FIELDS
```python
from typing import Optional

class Post(BaseModel):
    title: str
    content: str
    published: bool = False
    rating: Optiona[int] = None
```

Here we have an optional field __published__. It is optional because it has a default value that is assigned to it it the user does not assign one by default. We could assign it a value of True/False if we wanted to. We could use that value in the database to determine if the post is published or not.

To have a completely optional field, we can use __Optional__ from __typing__.
__rating__ is fully optional and hwhen not provided, it will be assigned a value of None.

The pydantic object has a method__dict()__ which converts it to a python dictionary.

```python
@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    print(new_post.dict())
    return {"message": "Post created successfully"}
```

## CRUD OPERATIONS

### creating and retrieving
STORING IN MEMORY
```python
my_posts = []

# creating a single post to memory - the array above
@app.post("/posts")
def create_post(post: Post):
    post_dict = post.dict()
    post_dict["id"] = randint(0, 1000000)
    my_posts.append(post_dict)
    return {"data": post_dict}

"""
with the code above, the default status code on success is 200, if we want to change it, we can do so by adding the status_code parameter to the function. We will add a status code that rerpresents success in creating a resource. We will use 201.
"""
@app.post("/posts", status_code=status.HTTP_201_CREATED)

# getting a single post from memory- the list above
def get_post_from_database(id: int):
    for post in my_posts:
        if post["id"] == id:
            return post

# retrieving the latest post
# We are bringing this section above the retrieval with id because they may collide
@app.get("/posts/latest")
def get_latest_post():
    return {"data": my_posts[-1]}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        response.status_code = status.HTTP_404_NOT_FOUND
        return {"detail": f"Post with id {id} not found"}
    return {"data": post}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"data": post}
```

### DELETING
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    my_posts.remove(post) # you could use the pop method
    return {"data": "Post deleted"}
```

### UPDATING
For updating, two methods are provided, PUT AND PATCH.
__PUT__ is used to update the entire resource. Even when you are updating a single element, you have to send the entire resource.

__PATCH__ is used to update a single element of the resource. It is used when you don't want to send the entire resource.

```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post):
    current = get_post_from_database(id)

    if not current:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")
    post_dict = post.dict()
    post_dict["id"] = id
    my_posts[id] = post_dict
    return {"data": post_dict}
```

## STRUCTURE
we currently have our working files in the base directory. We will create a folder called __app__ and move all our files there. We will also create a file called **__init__.py** in the base directory. This file will that folder to a python package.

Now with this new structure, to run our application using uvicorn, the command will change to:
```bash
uvicorn app.main:app --reload
```
__app__ is the name of the folder, __main__ is the name of the file and __app__ is the name of the instance of the class FastAPI.

***
***
# DATABASE
We don't interact with the database directly, instead we use a database management system. It sits in the middle between our application and the database. It is responsible for managing the database. It is also responsible for translating the data from the database to the application and vice versa.

We are going to use postgres as our database
### POSTGRES
Each instance of postgres can be carved into multiple separate databases. They can be operated separately.
install postgres and the pgAdmin to have a graphical user interface to manage the database.

in postgres when you insert items and want them to be returned back to you, you use the __returning__ keyword.
This will be useful when buidling our API since we want to send back the data that was inserted into the database.
```sql
INSERT INTO products (name, price, inventory) VALUES ('drves', 44, 1523) returning *;
```

while deleting items and want to see teh item you are deleting as it gets deleted, you could use the __return__ keyword.
```sql
DELETE FROM products where id = 11 RETURNING *;
```
***
***
### accessing the postgres db from our python file
```python
while True:
    try:
        conn = psycopg2.connect(host='localhost', database='fastapi', user='postgres', password='', cursor_factory=RealDictCursor)
        cursor = conn.cursor()
        print("DATABSE CONN IS A SUCCESS")
        break
    except Exception as error:
        print("DATABSE CONN IS A FAILURE", error)
        time.sleep(2)
```

In the code above we use a while loop to keep trying to connect if the connection fails.

__cursor_factory=RealDictCursor__ is used to return the data as a dictionary. This will be useful when we are returning the data to the user.

***
***
### retrieving all data from the database
```python
@app.get("/posts")
def get_posts():
    cursor.execute("SELECT * FROM posts")
    my_posts = cursor.fetchall()
    return {"data": my_posts}
```

***
***
### retrieving a single item from the database
```python
@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    cursor.execute("SELECT * FROM posts WHERE id = %s", (id,))
    post = cursor.fetchone()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"data": post}
```

__(id,)__ is a tuple. It is used to pass the id to the query. It is used to prevent sql injection.
We can also try __str(id),__ but it is not recommended since it is prone to sql injection.

***
***
### inserting data into the database
```python
cursor.execute("INSERT INTO posts (title, content, published) VALUES (%s, %s, %s) RETURNING *", (post.title, post.content, post.published))

new_post = cursor.fetchone()
conn.commit()
return {"data": new_post}
```

This way of inserting sanitizes the input hence preventing sql injection.
__RETURNING *__ is used to return the data that was inserted into the database.
__new_post = cursor.fetchone()__ is used to get the data that was inserted into the database.
__conn.commit()__ is used to commit the changes to the database. it pushes the changes to the database.

***
***

### DELETING DATA FROM THE DATABASE
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    cursor.execute("DELETE FROM posts WHERE id = %s returning *", (id,))
    deleted_post = cursor.fetchone()
    conn.commit()

    if not deleted_post:
        raise HTTPException(status_code=404, detail="Post not found")

    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

***
***

### UPDATING DATA IN THE DATABASE
```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post):
    cursor.execute("UPDATE posts SET title = %s, content = %s, published = %s WHERE id = %s RETURNING *", (post.title, post.content, post.published, id))
    
    updated_post = cursor.fetchone()
    conn.commit()

    if not updated_post:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")

    return {"data": updated_post}
```

***
***

## OBJECT RELATIONAL MAPPER (ORM)
ORM is a library that allows us to interact with the database using python objects. It allows us to interact with the database without writing sql queries.

## SQLALCHEMY

### INSTALLATION
```bash
pip install SQLAlchemy==1.4
```
sqlalchemy does not know how to talk to databases, it needs a database driver, the driver is determined by the database you choose, for us, we are using __postgres__ hence our driver is __psycopg2__.

```bash
pip install psycopg2-binary
```

The __fastApi__ documentation provides a way to integrate sqlalchemy with fastapi under the __ORM__ section.

### Connecting to the database

the format of the connection string and the engine:

```database.py``
```python
sqlalchemy_url = 'postgresql://<username>:<password>@<ip-address/hostname>/<database-name>'
sqlalchemy_url = 'postgresql://postgres:mankindjnr@127.0.0.1/fastapi'

engine = create_engine(sqlalchemy_url)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
```

Wit orms we no longer have to create tables with the pgadmin or the like, we can declare those tables using python models.

***

```models.py```

```python
from .database import Base
from sqlalchemy import Column, Integer, String, Text, DateTime
import datetime

class Post(Base):
    __tablename__ = 'posts'

    id = Column(Integer, primary_key=True, nullable=False)
    title = Column(String(255), nullable=False)
    content = Column(String, nullable=False)
    published = Column(Boolean, default=True, nullable=False)
    created = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))
```

__Base__ is the base class that is provided by sqlalchemy. It is used to create the tables in the database.
__Column(String(255))__ the string constraint is used for fields that do not expect large input while __Text__ is used for fields that expect large input, i.e. blog posts, articles. Use __Text__ when there is no limit to the number of characters that can be entered. __String__ when you want to limit the number of characters that can be entered. __String(255)__ means that the field can only take 255 characters.

```update to main.py```
```python
from . import models
from .database import engine, SessionLocal

models.Base.metadata.create_all(bind=engine)

app = FastAPI()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### testing if our connection worked
```python
@app.get("/sqlalchemy")
def test(db: Session = Depends(get_db)):
    return {"message": "Hello orm"}
```

When we run the code, the models we defined are checked if those tables exist in the database, if not, they are created, if they exist, nothing happens.

***
sqlalchemy does not handle databse changes, when you update a table and it already existed, those changes will not reflect in the database, to make those changes stick, we use another tool to __migrate__ our changes. The tool is __alembic__.

### testing
```python
@app.get("/sqlalchemy")
def test(db: Session = Depends(get_db)):
    posts = db.query(models.Post).all()
    return {"data": posts}
```
While working with sqlalchemy you need to call the connection to the database __db__.
hence
```python
db.query(models.Post).all()
```
the query __db.query(models.Post)__ is used to query the database and the __.all()__ is used to get all the data from the database and execute the query.

***
***

### retrieving all items with orm
```python
@app.post("/posts", status_code=status.HTTP_201_CREATED)
def create_post(post: Post, db: Session = Depends(get_db)):
    new_post = models.Post(title=post.title, content=post.content, published=post.published)
    return {"data": new_post}
```

***
***

### creating a single item with orm
```python
@app.post("/posts", status_code=status.HTTP_201_CREATED)
def create_post(post: Post, db: Session = Depends(get_db)):
    new_post = models.Post(title=post.title, content=post.content, published=post.published)

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return {"data": new_post}
```

We create the post and store it in the variable new_post
we then add the new post to the database
we then commit the changes to the database(saving them)
we then retrieve that post (__equivalent of return in raw sql__) using refresh adn store it in variable __new_post__
we then return the new_post

The above way of mapping items to the columsn will prove inefficient when our models grow, to solve that we can unpack the pydantic model using the __.dict()__ method.

```python
@app.post("/posts", status_code=status.HTTP_201_CREATED)
def create_post(post: Post, db: Session = Depends(get_db)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return {"data": new_post}
```

Now, it will not matter how many fields our models have, all the fields described in our pydantic model will be mapped to the columns in our database.

***
***

### retrieving a single item with orm
```python
@app.get("/posts/{id}")
def get_post(id: int, db: Session = Depends(get_db)):
    post = db.query(models.Post).filter(models.Post.id == id).first()

    if not post:
        raise HTTPException(status_code=404, detail=f"Post of id {id} not found")
    return {"data": post}
```

__db.query__ is used to query the database
__(models.Post)__ is the table we are querying, we have imported the models.py file and __Post__ is one of the model in that file.
__.filter(models.Post.id == id)__ is used to filter the data we want to retrieve. We are filtering the data by the id.

***
***

### Deleting a single item with orm
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int, db: Session = Depends(get_db)):
    deleted_post = db.query(models.Post).filter(models.Post.id == id)

    if deleted_post.first() == None:
        raise HTTPException(status_code=404, detail=f"Post of id {id} not found")

    deleted_post.delete(synchronize_session=False)
    db.commit()

    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

***
***

### Updating a single item with orm
```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post, db: Session = Depends(get_db)):
    required_post = db.query(models.Post).filter(models.Post.id == id)
    updated_post = required_post.first()

    if not updated_post:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")

    required_post.update(post.dict(), synchronize_session=False)
    db.commit()

    return {"data": required_post.first()}
```

***
***

## pydantic/schema model
```python

class Post(BaseModel):
    title: str
    content: str
    published: bool = True
```

This defines the structure of the data that the user should send through the api as well as the response by the fastAPI. It is used to validate the data sent to the server and the data sent back to the user. All data should meet the requirements of the schema.

## sqlalchemy model
```python
class Post(Base):
    __tablename__ = 'posts'

    id = Column(Integer, primary_key=True, nullable=False)
    title = Column(String(255), nullable=False)
    content = Column(String, nullable=False)
    published = Column(Boolean, server_default='TRUE', nullable=False)
    created = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))
```

This defines the structure of the data that will be stored in the database. It is used to validate the data that will be stored in the database.
It also creates the table in the database.

The two are different, while we don't need the pydantic model, it's useful since it allows us to validate the data sent to the server and the data sent back to the user and when it comes to api's, we want to be safe as possible.

### separating the schemas
```python
class CreatePost(BaseModel):
    title: str
    content: str
    published: bool = True

# we want the user while updating, to pass all the items
class UpdatePost(BaseModel):
    title: str
    content: str
    published: bool
```

#### REASON

We have the above schemas separate from the main file. To avoid clutter.
We have more that one schema above that represent similar data but for different api routes, this is because, sometimes you want the the data a user can update to be different from that of the one they can create.

IN the above snippet, the user is expected to pass all the values while updating, but when creating, the user is not expected to pass the published value, it is optional and has a default value of True.

If we wanted the user to only update on item we could:
```python
class UpdatePost(BaseModel):
    title: str
```
Here the user can only update the title alone.

### A better way to structure multiple related schemas
```python
class PostBase(BaseModel):
    title: str
    content: str
    published: bool = True

class PostCreate(PostBase):
    pass
```

This way, the __PostCreaet__ has all the atributes of PostBase using the __pass__ keyword. If we wanted to change the default value of published, we could do so in the __PostCreate__ class.

***
***

## SENDING A RESPONSE BACK

Defining a pydantic schema that will define the structure of the data that will be sent back to the user.
This is relevant because sometimes we may want to send only pieces of data back to the user and not the entire data.

Example: When a user creates an account, we don't want to send them back their password but we may want to send them their username and email.

```python
class PostResp(BaseModel):
    title: str
    content: str
    published: bool

    class Config:
        orm_mode = True
```

Now to use this:
```python
@app.post("/posts", status_code=status.HTTP_201_CREATED, response_model=schemas.PostResp)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

When we create a new field now, the data we send back to the user only has three fields, the __timestamp__ field is not sent back to the user since we did not include it in the __PostResp__ schema.

to include the timestamp field, we can add it to the __PostResp__ schema.

```python
from datetime import datetime

class PostResp(BaseModel):
    title: str
    content: str
    published: bool
    created: datetime

    class Config:
        orm_mode = True
```

to limit duplication, you can extend any class and add the fields you want to add.
we will inherit the __PostBase__ class and add the __created__ field to it.

the __postbase__ class has the __title__, __content__ and __published__ fields.

```python
class PostBase(PostBase):
    created: datetime

    class Config:
        orm_mode = True
```

When it comes to retrieving all responses with the defined response schema:
```python

@app.get("/posts", response_model=list[schemas.PostResp])
def get_posts(db: Session = Depends(get_db)):
    my_posts = db.query(models.Post).all()
    return my_posts
```

We have to use the __list__ keyword to tell fastapi that we are returning a list of items.


# USER FUNCTIONALITY
## Creating a User
```python
class UserCreate(BaseModel):
    email: EmailStr
    password: str

class UserResp(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

@app.post("/users", status_code=status.HTTP_201_CREATED, response_model=schemas.UserResp)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    hashed_password = pwd_context.hash(user.password)
    user.password = hashed_password
    
    new_user = models.User(**user.dict())

    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user
```

***
***

### fetching user data 
```python
@app.get("/users/{id}", response_model=schemas.UserResp)
def get_user(id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == id).first()

    if not user:
        raise HTTPException(status_code=404, detail=f"User of id {id} not found")
    return user
```

## ROUTERS
They will help us to separate our routes into different files. This will help us to avoid cluttering our main file.

```main.py```
```python
app.include_router(post.router)
app.include_router(users.router)
```

```post.py```

__THE PREFIX IS OPTIONAL - WHILE I HAVE USED IT IN THE LEARNING PROCESS, I DO NOT PREFER TO USE IT IN MY PROJECTS__
```python
router = APIRouter(
    prefix="/posts",
)


@router.get("/", response_model=list[schemas.PostResp])
def get_posts(db: Session = Depends(get_db)):
    my_posts = db.query(models.Post).all()
    return my_posts


@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.PostResp)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

### STYLING THE DOCS SO THAT ALL ROUTES ARE SECTIONED ACCORDING TO THEIR ACTIONS
```users.py```
```python
router = APIRouter(
    tags=["users"]
)
```

```post.py```
```python
router = APIRouter(
    tags=["posts"]
)
```

***
# IMPORTANT SECTION
***
## AUTHENTICATION
There are two ways of authenticating users, __session__ and __token__ authentication.

## JWT TOKEN AUTHENTICATION
We will use the jwt token authentication since its stateless and we don't have to store the token in the database nor in the api server. It is stored in the client side.

#### How it's used
The user logs in with their credentials and then they are assigned a __token__ which they will use to access the protected routes. The token is sent to the server with every request in the __header__ and the server will verify the token and if it's valid, it will grant the user access to the protected routes.

In the Jwt, when sending the token to the server, be careful witht the data you pass to the __payload__, it is not encrypted and can be decoded by anyone. Don't pass sensitive data to the payload. Also do not jam alot of info in the payload, it will make the token large and it will take time to send it to the server.

### logging user
```routes/auth.py```
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from .. import schemas, database, models, utils

router = APIRouter(
    tags = ['Authentication']
)

@router.post('/login')
def login(user_credentials: schemas.UserLogin, db: Session = Depends(database.get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.email).first()

    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Invalid credentials")

    if not utils.verify(user_credentials.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Incorrect credentials")

    

    return user
```

***
### implementing oauth2
```bash
pip install python-jose[cryptography]
```

```python
from jose import JWTError, jwt
from datetime import datetime, timedelta

# secret key
# algorithm
# expiration time

SECRET_KEY = "b7ffab7e88ff8ec8e6c258944ec6677542bd7a16431ef01c0b78aaea77b26e04"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# payload
def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```

__SECRET_KEY__ run the following command to generate a secret key
__expire__ current_time + time_to_expire(30 mins)
__to_encode.update__ is a copy of the data passed to the function and we are adding the expire time to it.

```bash
openssl rand -hex 32
```

### update to login route due to OAUTH2

```python
from fastapi import APIRouter, Depends, HTTPException, status, Response
from fastapi.security.oauth2 import OAuth2PasswordRequestForm

@router.post('/login')
def login(user_credentials: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.username).first()

    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Invalid credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Incorrect credentials")

    # the data we want in the payload to be passed here (email/id/username)
    access_token = oauth2.create_access_token(data={"user_id": user.id})

    return {"access_token" : access_token, "token_type": "bearer"}
```

The oauth password request form only returns username and password,so, our email will be stored under username hence we have to adjust our code accordingly.

Now when we are testing the api route, we will no longer user the __body__  section, we will use the __form-data__ section.
We will enter the username as key and pass the email as the value. We will do the same for the password.


### verifying the token (its not tampered with and not expired)
we will start by defining a schema for the token

***
As long there is data been sent to the api or from it, we will create __schemas__ for them to ensure compliance
***

```python
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    user_id: Optional[str] = None
```

The token data is what we send to the token creation function as payload. Its optional cause you get to decide what you want to send to the payload.

```python
def verify_access_token(token: str, credentials_exception):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        _id = payload.get("user_id")

        if _id is None:
            raise credentials_exception

        token_data = schemas.TokenData(_id=user_id)
    except JWTError:
        raise credentials_exception

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(database.get_db)):
    credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials", headers={"WWW-Authenticate": "Bearer"})

    return verify_access_token(token, credentials_exception)
```

__return verify_access_token(token, credentials_exception)__ returns the token_data on success and raises an error on failure.

To use it to block access to route (protecting a route to authoried users only):
```python
@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.PostResp)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db), user_id: int = Depends(oauth2.get_current_user)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

we have added the dependancy to the route, now, when we try to access the route without the token, we will get an error. __get_current_user: int = Depends(oauth2.get_current_user)__

### testing
to test the route with postman, we will first login and get the token, we will then copy the token and paste it in the __Authorization__ section of the __Headers__ tab. We will then add the __Bearer__ keyword before the token.


## POSTMAN
***
### environment
you should also use environments on postman to avoid having to copy and paste the token every time you want to test the route.

i.e: DEV, PROD, TEST

### env variables/access_token
you can also use global variables to store the token and use it in the headers section.


__setting the env variable__
```python
pm.environment.set("access_token", pm.response.json().access_token)
```

__retreiving the env variable__
```python
{{access_token}}
```
***